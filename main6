#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <limits>

int main() {
    std::ifstream fin("input.txt");
    std::ofstream fout("output.txt");

    // --- Проверка открытия файлов ---
    if (!fin.is_open()) {
        std::cerr << "Ошибка: не удалось открыть input.txt\n";
        return 1;
    }
    if (!fout.is_open()) {
        std::cerr << "Ошибка: не удалось открыть output.txt\n";
        return 1;
    }

    int k, n;
    std::string s;

    // --- Проверка корректности ввода ---
    if (!(fin >> k >> n >> s)) {
        fout << 0;
        std::cerr << "Ошибка: ожидались три значения (k n s)\n";
        return 0;
    }

    if (k != 2) {
        fout << 0;
        std::cerr << "Ошибка: k должно быть равно 2 (булева функция)\n";
        return 0;
    }

    if (n < 0 || n > 20) { // ограничим n, чтобы не было переполнения (2^20 = 1 048 576)
        fout << 0;
        std::cerr << "Ошибка: n должно быть в пределах 0..20\n";
        return 0;
    }

    std::size_t expected_size = 1u << n;
    if (s.size() != expected_size) {
        fout << 0;
        std::cerr << "Ошибка: длина строки s (" << s.size()
                  << ") не равна 2^n (" << expected_size << ")\n";
        return 0;
    }

    // --- Проверка, что строка содержит только 0 и 1 ---
    std::vector<int> f;
    f.reserve(expected_size);
    for (char c : s) {
        if (c != '0' && c != '1') {
            fout << 0;
            std::cerr << "Ошибка: строка содержит символ '" << c << "', ожидались только 0 и 1\n";
            return 0;
        }
        f.push_back(c - '0');
    }

    // --- Проверка на пустой ввод ---
    if (f.empty()) {
        fout << 0;
        std::cerr << "Ошибка: пустая таблица функции\n";
        return 0;
    }

    // --- Основная логика: проверка линейности / аффинности ---
    int c0 = f[0]; // свободный член (константа)
    std::vector<int> a(n);

    // вычисляем коэффициенты при x_i с учётом константы
    for (int i = 0; i < n; ++i)
        a[i] = f[1 << i] ^ c0;

    // проверяем все возможные комбинации переменных
    for (int x = 0; x < (1 << n); ++x) {
        int predicted = c0;
        for (int i = 0; i < n; ++i)
            if ((x >> i) & 1)
                predicted ^= a[i];
        if (predicted != f[x]) {
            fout << 0; // не совпало — функция нелинейная
            return 0;
        }
    }

    // если дошли сюда — функция линейная или аффинная
    fout << 1;
    return 0;
}
